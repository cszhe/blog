<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>建立SSCLI运行和调试环境 | Zongjian’s blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="建立SSCLI运行和调试环境" />
<meta name="author" content="omale" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="从微软网站上(http://msdn.microsoft.com/net/sscli)下载回来的SSCLI是一个15M的压缩包。本文介绍如编译，运行，调试SSCLI和如何察看它的代码。下文所述都是笔者使用的运行环境和方法。有可能有更好的方法，欢迎交流，我的电子邮件：xxx@msn.com。" />
<meta property="og:description" content="从微软网站上(http://msdn.microsoft.com/net/sscli)下载回来的SSCLI是一个15M的压缩包。本文介绍如编译，运行，调试SSCLI和如何察看它的代码。下文所述都是笔者使用的运行环境和方法。有可能有更好的方法，欢迎交流，我的电子邮件：xxx@msn.com。" />
<link rel="canonical" href="https://www.hezongjian.com/jian-li-sscliyun-xing-he-diao-shi-huan-jing.html" />
<meta property="og:url" content="https://www.hezongjian.com/jian-li-sscliyun-xing-he-diao-shi-huan-jing.html" />
<meta property="og:site_name" content="Zongjian’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2005-01-24T19:01:23-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="建立SSCLI运行和调试环境" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"omale"},"dateModified":"2005-01-24T19:01:23-05:00","datePublished":"2005-01-24T19:01:23-05:00","description":"从微软网站上(http://msdn.microsoft.com/net/sscli)下载回来的SSCLI是一个15M的压缩包。本文介绍如编译，运行，调试SSCLI和如何察看它的代码。下文所述都是笔者使用的运行环境和方法。有可能有更好的方法，欢迎交流，我的电子邮件：xxx@msn.com。","headline":"建立SSCLI运行和调试环境","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hezongjian.com/jian-li-sscliyun-xing-he-diao-shi-huan-jing.html"},"url":"https://www.hezongjian.com/jian-li-sscliyun-xing-he-diao-shi-huan-jing.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://www.hezongjian.com/feed.xml" title="Zongjian&apos;s blog" />
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Zongjian&#39;s blog</a>

    <nav class="site-nav">
      <a class="page-link" href="/">Home</a>
      <a class="page-link" href="/categories/">Categories</a>
      <a class="page-link" href="/tags/">Tags</a>
      <a class="page-link" href="/archive/">Archive</a>
    </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">建立SSCLI运行和调试环境</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2005-01-24T19:01:23-05:00" itemprop="datePublished">
        January 24, 2005
      </time></div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>从微软网站上(http://msdn.microsoft.com/net/sscli)下载回来的SSCLI是一个15M的压缩包。本文介绍如编译，运行，调试SSCLI和如何察看它的代码。下文所述都是笔者使用的运行环境和方法。有可能有更好的方法，欢迎交流，我的电子邮件：xxx@msn.com。</p>

<p>SSCLI是一个可以跨平台的实现，可以运行在Winodws，FreeBSD和Mac OS上，据说有些高手已经成功的把SSCLI跑在了Linux上。但是后面几个环境笔者不熟悉，所以Windows就成了不二之选。</p>

<p>安装必备的软件：</p>

<p>操作系统：  Microsoft Windows XP</p>

<p>其它软件：  Visual Studio.NET 2003专业版 （用来编译SSCLI，至少安装VC++.NET）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               Active Perl（Perl的引擎，用来编译SSCLI）

               Source Insight       (不错的源代码查看工具，可以方便的在代码之间进行符号跳转。用来查看SSCIL源代码)

               Windbg（微软的调试工具，用来调试SSCLI的运行情况）
</code></pre></div></div>

<p>编译SSCLI：</p>

<ol>
  <li>
    <p>把下载来的压缩文件解压缩到某个盘的根目录，笔者为F:\sscli。</p>
  </li>
  <li>
    <p>打开命令行窗口cmd.exe。把当前目录切换到F:\sscli。</p>
  </li>
  <li>
    <p>输入：</p>
  </li>
</ol>

<blockquote>
  <p>env.bat checked</p>
</blockquote>

<p>设置编译所需要的环境变量。SSCLI有三个编译版本。分别为：checked, fastchecked和free。free大概相当于C++中的release版本，有编译器优化，不能调试。fastchecked也有编译器优化，但是可以调试。checked是没有优化可以调试的版本。默认env.bat会把环境变量设置为fastchecked。但是调试经过编译器优化过的代码会有一些令人迷惑的地方，例如碰上循环消解……。所以选择checked版本最容易调试跟踪。</p>

<ol>
  <li>输入：</li>
</ol>

<blockquote>
  <p>buildall</p>
</blockquote>

<p>编译SSCLI。编译过程大概分为六个步骤，分别是：</p>

<p>a)         平台抽象层PAL和非托管工具，例如binplace。</p>

<p>b)        其他的非托管工具，例如资源编译器resourcecompiler等等。</p>

<p>c)        SSCLI的实现，还有C#编译器。</p>

<p>d)        精简过的.net framework类库。</p>

<p>e)         其他程序集，主要是序列化和Remoting支持。</p>

<p>f)         托管的编译器。Javascript的编译器jsc.exe等</p>

<p>如果运气足够好，经过半个小时左右，就可以大功告成了。如果不幸出错了，可以通过build log来解决。文件名为buildd.log，buildd.wrn和buildd.wrn。分散在各个子目录下。</p>

<ol>
  <li>测试：编译的结果会放在名为build的目录下。用cd转到该目录输入</li>
</ol>

<blockquote>
  <p>csc /?</p>
</blockquote>

<p>如果看到下面的输出，则基本上编译成功：</p>

<p>Microsoft (R) Visual C# Shared Source CLI Compiler version 1.0.0003</p>

<p>for Microsoft (R) Shared Source CLI version 1.0.0</p>

<p>Copyright (C) Microsoft Corporation 2002. All rights reserved.</p>

<p>运行和调试第一个程序</p>

<p>用notepad建立Hello.cs，文件内容如下：</p>

<p>using System;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> class Hello

 {

        static void Main(string[] args)

        {

               int x = 10;

               System.Console.WriteLine("Hello World, x is {0}", x);

        }

 }
</code></pre></div></div>

<p>把文件复制到F:\sscli\build\v1.x86chk.rotor，然后输入下面的命令行来编译该程序：</p>

<blockquote>
  <p>csc /debug+ /t:exe Hello.cs</p>
</blockquote>

<p>没有报错就说明编译成功（出了错的话，买本《C#入门到精通》什么的看看吧……）。会生成两个文件Hello.exe和Hello.ildb。前者就是包含托管代码的程序集，后者是用来调试用的，类似于VC生成的PDB文件。</p>

<p>这时直接双击Hello.exe或者在命令行里输入Hello.exe都可以看到想要得执行结果。但是我们却不能这样做，因为这样子是利用了Windows操作系统把Hello.exe加载进系统，然后在.net Framework中运行了Hello.exe。在MacOS或Unix下是不会有这种便宜赚的。SSCLI提供了一个工具clix，专门用来帮助我们代替完成加载工作。因此我们需要在命令行下输入：</p>

<blockquote>
  <p>clix Hello.exe</p>
</blockquote>

<p>这时，clix会帮助我们加载和执行Hello.exe，这才是只依赖SSCLI的方式。输出结果：</p>

<p>Hello World, x is 10</p>

<p>SSCLI提供了cordbg调试器（debugger）用来调试托管代码。编译结束后cordbg会放在F:\sscli\build\v1.x86chk.rotor\sdk\bin目录下。</p>

<p>在命令行下输入如下命令启动cordbg</p>

<blockquote>
  <p>sdk\bin\cordbg.exe</p>
</blockquote>

<p>系统进入cordbg命令行状态，显示如下：</p>

<p>Microsoft (R) Shared Source CLI Test Debugger Shell Version 1.0.0003.0</p>

<p>Copyright (C) Microsoft Corporation 1998-2002. All rights reserved.</p>

<p>(cordbg)</p>

<p>这时，输入?可以看到cordbg的帮助信息。</p>

<p>Usage: ? [<command /> …]</p>

<p>Displays debugger command descriptions. If no arguments</p>

<p>are passed, a list of debugger commands is displayed. If</p>

<p>one or more command arguments is provided, descriptions</p>

<p>are displayed for the specified commands. The ? command</p>

<p>is an alias for the help command.</p>

<p>The following commands are available:</p>

<p>ap[pdomainenum]     Display appdomains/assemblies/modules in the current process</p>

<p>a[ttach]            Attach to a running process</p>

<p>…………</p>

<p>cordbg是一个基于命令行的调试器，提供了设置断点，单步跟踪，查看变量值，查看源代码等调试器所必备的所有功能。有可能使用IDE习惯了的开发者一开始会不太习惯。但是熟悉了以后，效率也不会比IDE图形界面操作差多少。</p>

<p>这时，输入下面命令来启动要调试的程序：</p>

<p>(cordbg) run Hello.exe</p>

<p>Process 19432/0x4be8 created.</p>

<p>[thread 0x4a7c] Thread created.</p>

<p>011:                    int x = 10;</p>

<p>(cordbg) _</p>

<p>我们可以看到程序停在了要执行的第一条代码之前，等待下面的输入。通过命令，就可以进行一系列调试了。我们让程序直接执行到结束，然后退出cordbg：</p>

<p>(cordbg) g</p>

<p>Hello Wold, x is 10</p>

<p>[thread 0x4830] Thread created.</p>

<p>[thread 0x4a7c] Thread exited.</p>

<p>Process exited.</p>

<p>(cordbg) quit</p>

<p>F:\sscli\build\v1.x86chk.rotor&gt;</p>

<p>调试SSCLI的代码</p>

<p>cordbg是一个调试托管代码的好工具，然而整个CLI执行引擎中最精彩的部分例如垃圾回收，元数据等都是用非托管代码编写的。跟踪调试这一部分代码cordbg就无能为力了。目前为止，似乎还没有一个调试器可以既调试托管代码又调试非托管代码（有些调试器可以加载extension以实现少量支持）。好在在Windows下，SSCLI也不过就是一个标准windows程序，否则SSCLI也没法在Windows上跑啊。所以我们仍然可以用调试windows程序的办法去调试SSCLI。</p>

<p>调试一个Windows程序无非需要这么几样东西：调试器，pdb符号文件和源代码。源代码不必多说，符号文件在编译SSCLI的时候已经自动生成了。放在F:\sscli\build\v1.x86chk.rotor\Symbols下面。调试器有多种选择，最简单的方法就直接使用Visual Studio.net。鉴于功能和实用，笔者选用了Windbg，该软件可以从http://www.microsoft.com/ddk/debugging/下载。</p>

<p>安装Windbg完毕后，建立一个小的批处理程序，内容如下：</p>

<p>F:</p>

<p>cd F:\sscli\build\v1.x86chk.rotor</p>

<p>call F:\debug\windbg clix Hello.exe</p>

<p>其中F:\debug是Windbg的安装目录。下次每次Double Click这个小批处理程序，就可以直接启动Windbg，并调试通过clix运行的Hello.exe程序。</p>

<p>这时在命令窗口输入：</p>

<p>0:000&lt;/a&gt;&gt;bp main</p>

<p>0:000&gt;g</p>

<p>其中第一条命令的意思是在主函数main处设置断点，g命令是使程序继续执行，当然，程序执行到main的时候，就停下来了。如下图所示。</p>

<p><a href="http://images.blogcn.com/2005/1/24/12/omale,20050124234733.jpg" target="_blank"><img border="0" onload="if(this.width&gt;screen.width/2)this.width=screen.width/2;" src="http://images.blogcn.com/2005/1/24/12/omale,20050124234733.jpg" /></a></p>

<p>这里有必要澄清一个问题，有人或许会问，main不就是程序执行的第一行代码么？为什么要还要go才能撞上main。其实Windows下一个应用程序执行的第一条指令写在PE文件头的某个位置，一般是0x0400000，这个地方的函数的名字官方叫WinMainCRTStartup。这个函数作一些初始化工作，然后才会去调用main或者WinMain。也就是我们看到的程序入口点函数。</p>

<p>下面我们简单的分析一下clix的代码。Clix是个很简单的程序，首先，main函数解析命令行参数，收集三样东西CLI运行时所在的库文件名，托管可执行文件的名称和命令行参数，分别放在pRuntimeName, pModuleName和pActualCmdLine中，然后调用Launch函数。下面是简化的main函数代码。</p>

<p>int __cdecl main(int argc, char **argv)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WCHAR* pRuntimeName;

WCHAR* pModuleName;

WCHAR* pActualCmdLine;

// First, parse the program name. Anything up to the first whitespace outside 

// a quoted substring is accepted (algorithm from clr/src/vm/util.cpp)

pRuntimeName = pdst;

 

// Now, load the runtime from the clix directory

 

// Parse the first arg &amp;#8211; the name of the module to run

pModuleName = pdst;

 

nExitCode = Launch(pRuntimeName, pModuleName, pActualCmdLine);

 

return nExitCode;
</code></pre></div></div>

<p>}</p>

<p>使用bp命令在Launch一句设置断点，然后go，当断点hit的时候，输入下列命令察看三个参数的值：</p>

<p>0:000&gt; dt pRuntimeName</p>

<p>Local var @ 0x6ff30 Type unsigned short*</p>

<p>0x002b2670</p>

<p>-&gt; 0x73</p>

<p>0:000&gt; du 0x002b2670</p>

<p>002b2670  “sscoree.dll”</p>

<p>其中dt是显示pRuntimeName的类型和地址，du是显示一个unicode的字符串。依此，我们可以得到三个参数的值分别是：”sscoree.dll”，”Hello.exe”和”Hello.exe”。后面两个重复的原因是我们Hello.exe后面并没有其他参数，否则pActualCmdLine的值会加上其他参数。</p>

<p>然后我们用t命令跟踪到Launch函数里面去。下面是精简过的Launch代码。</p>

<p>DWORD Launch(WCHAR* pRunTime, WCHAR* pFileName, WCHAR* pCmdLine)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// open the file &amp; map it

hFile = ::CreateFile(pFileName, GENERIC\_READ, FILE\_SHARE_READ,

                     0, OPEN_EXISTING, 0, 0);

   

hMapFile = ::CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0, NULL);

pModule = ::MapViewOfFile(hMapFile, FILE\_MAP\_COPY, 0, 0, 0);

 

// check the DOS headers

pdosHeader = (IMAGE\_DOS\_HEADER*) pModule;

   

// check the NT headers

pNtHeaders = (IMAGE\_NT\_HEADERS32\*) ((BYTE\*)pModule + VAL32(pdosHeader-&gt;e_lfanew));

  

// check the COR headers

pSectionHeader = (PIMAGE\_SECTION\_HEADER) Cor_RtlImageRvaToVa(pNtHeaders, (PBYTE)pModule, 

    

// load the runtime and go

hRuntime = ::LoadLibrary(pRunTime);

  

__int32 (STDMETHODCALLTYPE * pCorExeMain2)(

       &amp; nbsp;PBYTE   pUnmappedPE,                // -&gt; memory mapped code

        DWORD   cUnmappedPE,                // Size of memory mapped code

        LPWSTR  pImageNameIn,               // -&gt; Executable Name

        LPWSTR  pLoadersFileName,           // -&gt; Loaders Name

        LPWSTR  pCmdLine);                  // -&gt; Command Line

 

\*((VOID\**)&amp;pCorExeMain2) = (LPVOID) ::GetProcAddress(hRuntime, "_CorExeMain2");

 

nExitCode = (int)pCorExeMain2((PBYTE)pModule, dwSize, 

          pFileName,                  // -&gt; Executable Name

          NULL,                       // -&gt; Loaders Name

          pCmdLine);                  // -&gt; Command Line

 

return nExitCode;
</code></pre></div></div>

<p>}</p>

<p>函数的功能很简单，首先把Hello.exe作为内存映射文件加载到进程的地址空间内。然后对合法性作必要的检查，最后加载sscoree.dll，然后找到入口函数_CorExeMain2的地址，并且转到那个函数去执行。</p>

<p>我们可以在最后一句设断点，然后用t命令跟进_CorExeMain2的函数里面去。这时，程序离开了clix，转到了F:\sscli\clr\src\vm\ceemain.cpp中执行。欢迎来到.NET虚拟机内部。</p>

<p>跟踪SSCLI的动态执行</p>

<p>由于虚拟机是一个非常复杂的环境，.NET Assembly的执行也相当复杂，牵扯到多线程，同步等等，有些问题很难通过调试器一行一行跟踪代码来发现，这时候所需要的是动态的环境，也就是要得到程序真正执行的时候的一些信息。</p>

<p>好在SSCLI提供了功能极为强大的Log功能，可以动态的记录很多代码的执行。其基本思想就是设置一些环境变量，然后SSCLI的代码会根据这些预先设置的环境变量来输出一些调试信息。例如我们在命令行窗口下输入下面的命令，就可以跟踪JIT编译器所即时编译的所有函数：</p>

<blockquote>
  <p>set COMPlus_JitTrace=1</p>
</blockquote>

<blockquote>
  <p>clix Hello.exe</p>
</blockquote>

<p>程序执行的时候就会输出大量的信息，如下所示：</p>

<p>Method SetupDomain Class System.AppDomain</p>

<p>Method .cctor Class System.Runtime.Remoting.Proxies.RealProxy</p>

<p>Method .ctor Class System.AppDomainSetup</p>

<p>Method .ctor Class System.Object</p>

<p>Method SetupFusionStore Class System.AppDomain</p>

<p>Method get_Value Class System.AppDomainSetup</p>

<p>Method .cctor Class System.String</p>

<p>Method LastIndexOfAny Class System.String</p>

<p>Method get_Length Class System.String</p>

<p>…………</p>

<p>随机文档\docs\techinfo\logging.html提供了对Log功能的完整介绍。在此就不再多做敷述。</p>

<p>结束语</p>

<p>除了上面介绍的一些工具方法外，在几十万行代码中来回穿梭，Source Insight是一个不可缺少的好帮手，由于介绍Source Insight的使用超出了本文的范畴，读者可以查阅相关的资料。有了上面的环境，方法，工具，我们下一步就可以向SSCLI的深处探秘了。</p>


  </div>

  <a class="u-url" href="/jian-li-sscliyun-xing-he-diao-shi-huan-jing.html" hidden></a>
</article>


      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Zongjian He</li>
          <li><a class="u-email" href="mailto:"></a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Personal blog of Zongjian He</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list">
  <li>
    <a href="https://www.hezongjian.com/feed.xml" target="_blank" title="Subscribe to syndication feed">
      <svg class="svg-icon grey" viewbox="0 0 16 16">
        <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
          11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
          13.806c0-1.21.983-2.195 2.194-2.195zM10.606
          16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
        />
      </svg>
    </a>
  </li>
</ul>
</div>

  </div>

</footer>

</body>

</html>
