---
id: 9761
title: 建立SSCLI运行和调试环境
date: 2005-01-25T00:01:23+00:00
author: omale
layout: post
guid: http://hezongjian.com/blog/?p=9761
permalink: '/2005/01/25/%e5%bb%ba%e7%ab%8bsscli%e8%bf%90%e8%a1%8c%e5%92%8c%e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83-2/'
categories:
  - 未分类
  - 计算机技术
tags:
  - C++
  - 微软
  - 软件
---
从微软网站上(http://msdn.microsoft.com/net/sscli)下载回来的SSCLI是一个15M的压缩包。本文介绍如编译，运行，调试SSCLI和如何察看它的代码。下文所述都是笔者使用的运行环境和方法。有可能有更好的方法，欢迎交流，我的电子邮件：xxx@msn.com。

SSCLI是一个可以跨平台的实现，可以运行在Winodws，FreeBSD和Mac&nbsp;OS上，据说有些高手已经成功的把SSCLI跑在了Linux上。但是后面几个环境笔者不熟悉，所以Windows就成了不二之选。

安装必备的软件：
	  
操作系统：&nbsp;&nbsp;Microsoft&nbsp;Windows&nbsp;XP

其它软件：&nbsp;&nbsp;Visual&nbsp;Studio.NET&nbsp;2003专业版&nbsp;（用来编译SSCLI，至少安装VC++.NET）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Active&nbsp;Perl（Perl的引擎，用来编译SSCLI）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source&nbsp;Insight&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(不错的源代码查看工具，可以方便的在代码之间进行符号跳转。用来查看SSCIL源代码)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Windbg（微软的调试工具，用来调试SSCLI的运行情况）

编译SSCLI：
	  
1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把下载来的压缩文件解压缩到某个盘的根目录，笔者为F:\sscli。

2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开命令行窗口cmd.exe。把当前目录切换到F:\sscli。

3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入：

>&nbsp;env.bat&nbsp;checked&nbsp;

设置编译所需要的环境变量。SSCLI有三个编译版本。分别为：checked,&nbsp;fastchecked和free。free大概相当于C++中的release版本，有编译器优化，不能调试。fastchecked也有编译器优化，但是可以调试。checked是没有优化可以调试的版本。默认env.bat会把环境变量设置为fastchecked。但是调试经过编译器优化过的代码会有一些令人迷惑的地方，例如碰上循环消解&hellip;&hellip;。所以选择checked版本最容易调试跟踪。

4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入：

>&nbsp;buildall&nbsp;

编译SSCLI。编译过程大概分为六个步骤，分别是：

a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平台抽象层PAL和非托管工具，例如binplace。

b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他的非托管工具，例如资源编译器resourcecompiler等等。

c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSCLI的实现，还有C#编译器。

d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;精简过的.net&nbsp;framework类库。

e)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他程序集，主要是序列化和Remoting支持。

f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;托管的编译器。Javascript的编译器jsc.exe等

如果运气足够好，经过半个小时左右，就可以大功告成了。如果不幸出错了，可以通过build&nbsp;log来解决。文件名为buildd.log，buildd.wrn和buildd.wrn。分散在各个子目录下。

5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试：编译的结果会放在名为build的目录下。用cd转到该目录输入

>&nbsp;csc&nbsp;/?

如果看到下面的输出，则基本上编译成功：

Microsoft&nbsp;(R)&nbsp;Visual&nbsp;C#&nbsp;Shared&nbsp;Source&nbsp;CLI&nbsp;Compiler&nbsp;version&nbsp;1.0.0003

for&nbsp;Microsoft&nbsp;(R)&nbsp;Shared&nbsp;Source&nbsp;CLI&nbsp;version&nbsp;1.0.0

Copyright&nbsp;(C)&nbsp;Microsoft&nbsp;Corporation&nbsp;2002.&nbsp;All&nbsp;rights&nbsp;reserved.

运行和调试第一个程序
	  
用notepad建立Hello.cs，文件内容如下：

&nbsp;

using&nbsp;System;

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Hello

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;Main(string[]&nbsp;args)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;10;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.Console.WriteLine("Hello&nbsp;World,&nbsp;x&nbsp;is&nbsp;{0}",&nbsp;x);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;

把文件复制到F:\sscli\build\v1.x86chk.rotor，然后输入下面的命令行来编译该程序：

>csc&nbsp;/debug+&nbsp;/t:exe&nbsp;Hello.cs

没有报错就说明编译成功（出了错的话，买本《C#入门到精通》什么的看看吧&hellip;&hellip;）。会生成两个文件Hello.exe和Hello.ildb。前者就是包含托管代码的程序集，后者是用来调试用的，类似于VC生成的PDB文件。

这时直接双击Hello.exe或者在命令行里输入Hello.exe都可以看到想要得执行结果。但是我们却不能这样做，因为这样子是利用了Windows操作系统把Hello.exe加载进系统，然后在.net&nbsp;Framework中运行了Hello.exe。在MacOS或Unix下是不会有这种便宜赚的。SSCLI提供了一个工具clix，专门用来帮助我们代替完成加载工作。因此我们需要在命令行下输入：

>clix&nbsp;Hello.exe

这时，clix会帮助我们加载和执行Hello.exe，这才是只依赖SSCLI的方式。输出结果：

Hello&nbsp;World,&nbsp;x&nbsp;is&nbsp;10

SSCLI提供了cordbg调试器（debugger）用来调试托管代码。编译结束后cordbg会放在F:\sscli\build\v1.x86chk.rotor\sdk\bin目录下。

在命令行下输入如下命令启动cordbg

>sdk\bin\cordbg.exe

系统进入cordbg命令行状态，显示如下：

Microsoft&nbsp;(R)&nbsp;Shared&nbsp;Source&nbsp;CLI&nbsp;Test&nbsp;Debugger&nbsp;Shell&nbsp;Version&nbsp;1.0.0003.0

Copyright&nbsp;(C)&nbsp;Microsoft&nbsp;Corporation&nbsp;1998-2002.&nbsp;All&nbsp;rights&nbsp;reserved.

&nbsp;

(cordbg)

这时，输入?可以看到cordbg的帮助信息。

Usage:&nbsp;?&nbsp;[<command>&nbsp;&#8230;]

Displays&nbsp;debugger&nbsp;command&nbsp;descriptions.&nbsp;If&nbsp;no&nbsp;arguments

are&nbsp;passed,&nbsp;a&nbsp;list&nbsp;of&nbsp;debugger&nbsp;commands&nbsp;is&nbsp;displayed.&nbsp;If

one&nbsp;or&nbsp;more&nbsp;command&nbsp;arguments&nbsp;is&nbsp;provided,&nbsp;descriptions

are&nbsp;displayed&nbsp;for&nbsp;the&nbsp;specified&nbsp;commands.&nbsp;The&nbsp;?&nbsp;command

is&nbsp;an&nbsp;alias&nbsp;for&nbsp;the&nbsp;help&nbsp;command.

&nbsp;

The&nbsp;following&nbsp;commands&nbsp;are&nbsp;available:

&nbsp;

ap[pdomainenum]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Display&nbsp;appdomains/assemblies/modules&nbsp;in&nbsp;the&nbsp;current&nbsp;process

&nbsp;

a[ttach]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attach&nbsp;to&nbsp;a&nbsp;running&nbsp;process

&hellip;&hellip;&hellip;&hellip;

cordbg是一个基于命令行的调试器，提供了设置断点，单步跟踪，查看变量值，查看源代码等调试器所必备的所有功能。有可能使用IDE习惯了的开发者一开始会不太习惯。但是熟悉了以后，效率也不会比IDE图形界面操作差多少。

这时，输入下面命令来启动要调试的程序：

(cordbg)&nbsp;run&nbsp;Hello.exe

Process&nbsp;19432/0x4be8&nbsp;created.

[thread&nbsp;0x4a7c]&nbsp;Thread&nbsp;created.

&nbsp;

011:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;10;

(cordbg)&nbsp;_

我们可以看到程序停在了要执行的第一条代码之前，等待下面的输入。通过命令，就可以进行一系列调试了。我们让程序直接执行到结束，然后退出cordbg：

(cordbg)&nbsp;g

Hello&nbsp;Wold,&nbsp;x&nbsp;is&nbsp;10

[thread&nbsp;0x4830]&nbsp;Thread&nbsp;created.

[thread&nbsp;0x4a7c]&nbsp;Thread&nbsp;exited.

Process&nbsp;exited.

(cordbg)&nbsp;quit

&nbsp;

F:\sscli\build\v1.x86chk.rotor>

调试SSCLI的代码
	  
cordbg是一个调试托管代码的好工具，然而整个CLI执行引擎中最精彩的部分例如垃圾回收，元数据等都是用非托管代码编写的。跟踪调试这一部分代码cordbg就无能为力了。目前为止，似乎还没有一个调试器可以既调试托管代码又调试非托管代码（有些调试器可以加载extension以实现少量支持）。好在在Windows下，SSCLI也不过就是一个标准windows程序，否则SSCLI也没法在Windows上跑啊。所以我们仍然可以用调试windows程序的办法去调试SSCLI。

调试一个Windows程序无非需要这么几样东西：调试器，pdb符号文件和源代码。源代码不必多说，符号文件在编译SSCLI的时候已经自动生成了。放在F:\sscli\build\v1.x86chk.rotor\Symbols下面。调试器有多种选择，最简单的方法就直接使用Visual&nbsp;Studio.net。鉴于功能和实用，笔者选用了Windbg，该软件可以从http://www.microsoft.com/ddk/debugging/下载。

安装Windbg完毕后，建立一个小的批处理程序，内容如下：

F:

cd&nbsp;F:\sscli\build\v1.x86chk.rotor

call&nbsp;F:\debug\windbg&nbsp;clix&nbsp;Hello.exe

其中F:\debug是Windbg的安装目录。下次每次Double&nbsp;Click这个小批处理程序，就可以直接启动Windbg，并调试通过clix运行的Hello.exe程序。

这时在命令窗口输入：

0:000</a>>bp&nbsp;main

0:000>g

其中第一条命令的意思是在主函数main处设置断点，g命令是使程序继续执行，当然，程序执行到main的时候，就停下来了。如下图所示。&nbsp;

<a href="http://images.blogcn.com/2005/1/24/12/omale,20050124234733.jpg" target="_blank"><img border="0" onload="if(this.width>screen.width/2)this.width=screen.width/2;" src="http://images.blogcn.com/2005/1/24/12/omale,20050124234733.jpg" /></a>

这里有必要澄清一个问题，有人或许会问，main不就是程序执行的第一行代码么？为什么要还要go才能撞上main。其实Windows下一个应用程序执行的第一条指令写在PE文件头的某个位置，一般是0x0400000，这个地方的函数的名字官方叫WinMainCRTStartup。这个函数作一些初始化工作，然后才会去调用main或者WinMain。也就是我们看到的程序入口点函数。

下面我们简单的分析一下clix的代码。Clix是个很简单的程序，首先，main函数解析命令行参数，收集三样东西CLI运行时所在的库文件名，托管可执行文件的名称和命令行参数，分别放在pRuntimeName,&nbsp;pModuleName和pActualCmdLine中，然后调用Launch函数。下面是简化的main函数代码。

&nbsp;

int&nbsp;__cdecl&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)

{

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;WCHAR*&nbsp;pRuntimeName;

&nbsp;&nbsp;&nbsp;&nbsp;WCHAR*&nbsp;pModuleName;

&nbsp;&nbsp;&nbsp;&nbsp;WCHAR*&nbsp;pActualCmdLine;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;First,&nbsp;parse&nbsp;the&nbsp;program&nbsp;name.&nbsp;Anything&nbsp;up&nbsp;to&nbsp;the&nbsp;first&nbsp;whitespace&nbsp;outside&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;quoted&nbsp;substring&nbsp;is&nbsp;accepted&nbsp;(algorithm&nbsp;from&nbsp;clr/src/vm/util.cpp)

&nbsp;&nbsp;&nbsp;&nbsp;pRuntimeName&nbsp;=&nbsp;pdst;

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Now,&nbsp;load&nbsp;the&nbsp;runtime&nbsp;from&nbsp;the&nbsp;clix&nbsp;directory

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Parse&nbsp;the&nbsp;first&nbsp;arg&nbsp;&#8211;&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;module&nbsp;to&nbsp;run

&nbsp;&nbsp;&nbsp;&nbsp;pModuleName&nbsp;=&nbsp;pdst;

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;nExitCode&nbsp;=&nbsp;Launch(pRuntimeName,&nbsp;pModuleName,&nbsp;pActualCmdLine);

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nExitCode;

}

使用bp命令在Launch一句设置断点，然后go，当断点hit的时候，输入下列命令察看三个参数的值：

0:000>&nbsp;dt&nbsp;pRuntimeName

Local&nbsp;var&nbsp;@&nbsp;0x6ff30&nbsp;Type&nbsp;unsigned&nbsp;short*

0x002b2670&nbsp;

&nbsp;->&nbsp;0x73

0:000>&nbsp;du&nbsp;0x002b2670

002b2670&nbsp;&nbsp;"sscoree.dll"

其中dt是显示pRuntimeName的类型和地址，du是显示一个unicode的字符串。依此，我们可以得到三个参数的值分别是："sscoree.dll"，"Hello.exe&rdquo;和"Hello.exe&rdquo;。后面两个重复的原因是我们Hello.exe后面并没有其他参数，否则pActualCmdLine的值会加上其他参数。

然后我们用t命令跟踪到Launch函数里面去。下面是精简过的Launch代码。

&nbsp;

DWORD&nbsp;Launch(WCHAR\*&nbsp;pRunTime,&nbsp;WCHAR\*&nbsp;pFileName,&nbsp;WCHAR*&nbsp;pCmdLine)

{

&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;open&nbsp;the&nbsp;file&nbsp;&&nbsp;map&nbsp;it

&nbsp;&nbsp;&nbsp;&nbsp;hFile&nbsp;=&nbsp;::CreateFile(pFileName,&nbsp;GENERIC\_READ,&nbsp;FILE\_SHARE_READ,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;OPEN_EXISTING,&nbsp;0,&nbsp;0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;hMapFile&nbsp;=&nbsp;::CreateFileMapping(hFile,&nbsp;NULL,&nbsp;PAGE_WRITECOPY,&nbsp;0,&nbsp;0,&nbsp;NULL);

&nbsp;&nbsp;&nbsp;&nbsp;pModule&nbsp;=&nbsp;::MapViewOfFile(hMapFile,&nbsp;FILE\_MAP\_COPY,&nbsp;0,&nbsp;0,&nbsp;0);

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;check&nbsp;the&nbsp;DOS&nbsp;headers

&nbsp;&nbsp;&nbsp;&nbsp;pdosHeader&nbsp;=&nbsp;(IMAGE\_DOS\_HEADER*)&nbsp;pModule;

&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;check&nbsp;the&nbsp;NT&nbsp;headers

&nbsp;&nbsp;&nbsp;&nbsp;pNtHeaders&nbsp;=&nbsp;(IMAGE\_NT\_HEADERS32\*)&nbsp;((BYTE\*)pModule&nbsp;+&nbsp;VAL32(pdosHeader->e_lfanew));

&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;check&nbsp;the&nbsp;COR&nbsp;headers

&nbsp;&nbsp;&nbsp;&nbsp;pSectionHeader&nbsp;=&nbsp;(PIMAGE\_SECTION\_HEADER)&nbsp;Cor_RtlImageRvaToVa(pNtHeaders,&nbsp;(PBYTE)pModule,&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;load&nbsp;the&nbsp;runtime&nbsp;and&nbsp;go

&nbsp;&nbsp;&nbsp;&nbsp;hRuntime&nbsp;=&nbsp;::LoadLibrary(pRunTime);

&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;__int32&nbsp;(STDMETHODCALLTYPE&nbsp;*&nbsp;pCorExeMain2)(

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;& nbsp;PBYTE&nbsp;&nbsp;&nbsp;pUnmappedPE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;->&nbsp;memory&nbsp;mapped&nbsp;code

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;&nbsp;&nbsp;cUnmappedPE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Size&nbsp;of&nbsp;memory&nbsp;mapped&nbsp;code

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPWSTR&nbsp;&nbsp;pImageNameIn,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;->&nbsp;Executable&nbsp;Name

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPWSTR&nbsp;&nbsp;pLoadersFileName,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;->&nbsp;Loaders&nbsp;Name

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPWSTR&nbsp;&nbsp;pCmdLine);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;->&nbsp;Command&nbsp;Line

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;\*((VOID\**)&pCorExeMain2)&nbsp;=&nbsp;(LPVOID)&nbsp;::GetProcAddress(hRuntime,&nbsp;"_CorExeMain2");

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;nExitCode&nbsp;=&nbsp;(int)pCorExeMain2((PBYTE)pModule,&nbsp;dwSize,&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pFileName,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;->&nbsp;Executable&nbsp;Name

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;->&nbsp;Loaders&nbsp;Name

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pCmdLine);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;->&nbsp;Command&nbsp;Line

&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nExitCode;

}

函数的功能很简单，首先把Hello.exe作为内存映射文件加载到进程的地址空间内。然后对合法性作必要的检查，最后加载sscoree.dll，然后找到入口函数_CorExeMain2的地址，并且转到那个函数去执行。

我们可以在最后一句设断点，然后用t命令跟进_CorExeMain2的函数里面去。这时，程序离开了clix，转到了F:\sscli\clr\src\vm\ceemain.cpp中执行。欢迎来到.NET虚拟机内部。

跟踪SSCLI的动态执行
	  
由于虚拟机是一个非常复杂的环境，.NET&nbsp;Assembly的执行也相当复杂，牵扯到多线程，同步等等，有些问题很难通过调试器一行一行跟踪代码来发现，这时候所需要的是动态的环境，也就是要得到程序真正执行的时候的一些信息。

好在SSCLI提供了功能极为强大的Log功能，可以动态的记录很多代码的执行。其基本思想就是设置一些环境变量，然后SSCLI的代码会根据这些预先设置的环境变量来输出一些调试信息。例如我们在命令行窗口下输入下面的命令，就可以跟踪JIT编译器所即时编译的所有函数：

>set&nbsp;COMPlus_JitTrace=1

>clix&nbsp;Hello.exe

程序执行的时候就会输出大量的信息，如下所示：

Method&nbsp;SetupDomain&nbsp;Class&nbsp;System.AppDomain&nbsp;

Method&nbsp;.cctor&nbsp;Class&nbsp;System.Runtime.Remoting.Proxies.RealProxy&nbsp;

Method&nbsp;.ctor&nbsp;Class&nbsp;System.AppDomainSetup&nbsp;

Method&nbsp;.ctor&nbsp;Class&nbsp;System.Object&nbsp;

Method&nbsp;SetupFusionStore&nbsp;Class&nbsp;System.AppDomain&nbsp;

Method&nbsp;get_Value&nbsp;Class&nbsp;System.AppDomainSetup&nbsp;

Method&nbsp;.cctor&nbsp;Class&nbsp;System.String&nbsp;

Method&nbsp;LastIndexOfAny&nbsp;Class&nbsp;System.String&nbsp;

Method&nbsp;get_Length&nbsp;Class&nbsp;System.String&nbsp;

&hellip;&hellip;&hellip;&hellip;

随机文档\docs\techinfo\logging.html提供了对Log功能的完整介绍。在此就不再多做敷述。

结束语
	  
除了上面介绍的一些工具方法外，在几十万行代码中来回穿梭，Source&nbsp;Insight是一个不可缺少的好帮手，由于介绍Source&nbsp;Insight的使用超出了本文的范畴，读者可以查阅相关的资料。有了上面的环境，方法，工具，我们下一步就可以向SSCLI的深处探秘了。

&nbsp;