---
id: 9792
title: Windows CE下访问物理内存的方法
date: 2005-06-23T21:19:32+00:00
author: omale
layout: post
guid: http://hezongjian.com/blog/?p=9792
permalink: '/2005/06/23/windows-ce%e4%b8%8b%e8%ae%bf%e9%97%ae%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e7%9a%84%e6%96%b9%e6%b3%95/'
categories:
  - 嵌入式
  - 未分类
  - 计算机技术
tags:
  - Windows CE
  - 嵌入式
---
嵌入式设备与桌面PC的一个显著不同是它的应用程序中通常需要直接访问某一段物理内存，这在驱动程序中对物理内存的访问尤为重要，尤其是像ARM体系结构下，I/O端口也被映射成某一个物理内存地址。因此，与桌面版本Windows相比，Windows&nbsp;CE提供了相对简单的物理内存访问方式。无论是驱动程序还是应用程序都可以通过API访问某一段物理内存。  
Windows&nbsp;CE的有些函数中需要用到物理内存结构体PHYSICAL\_ADDRESS，&nbsp;Windows&nbsp;CE在ceddk.h中定义了PHYSICAL\_ADDRESS，它其实是LARGE_INTEGER类型，其定义如下：  
<font color='#008000' >//&nbsp;in&nbsp;ceddk.h</font>  
<font color='#0000ff' >typedef</font>&nbsp;LARGE\_INTEGER&nbsp;PHYSICAL\_ADDRESS,&nbsp;*PPHYSICAL_ADDRESS;  
<font color='#008000' >//&nbsp;in&nbsp;winnt.h</font>  
<font color='#0000ff' >typedef</font>&nbsp;<font color='#0000ff' >union</font>&nbsp;\_LARGE\_INTEGER{  
&nbsp;&nbsp;<font color='#0000ff' >struct</font>{  
&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;LowPart;  
&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >LONG</font>&nbsp;HighPart;  
&nbsp;&nbsp;};  
&nbsp;&nbsp;LONGLONG&nbsp;QuadPart;  
}&nbsp;LARGE_INTEGER;  
可见，Windows&nbsp;CE中用64个Bit来代表物理地址，对于大多数32位的CPU而言，只需要把它的HighPart设置为0就可以了。  
如果要直接访问某一个地址的物理内存，Windows&nbsp;CE提供了VirtualAlloc()和VirtualCopy()函数，VirtualAlloc负责在虚拟内存空间内保留一段虚拟内存，而VirtualCopy负责把一段物理内存和虚拟内存绑定，这样，最终对物理内存的访问还是通过虚拟地址进行。它们的声明如下：  
<font color='#008000' >//&nbsp;申请虚拟内存</font>  
LPVOID&nbsp;VirtualAlloc(  
&nbsp;&nbsp;LPVOID&nbsp;lpAddress,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;希望的虚拟内存起始地址</font>  
&nbsp;&nbsp;DWORD&nbsp;dwSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;以字节为单位的大小</font>  
&nbsp;&nbsp;DWORD&nbsp;flAllocationType,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;申请类型，分为Reserve和Commit</font>  
&nbsp;&nbsp;DWORD&nbsp;flProtect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;访问权限</font>  
);  
<font color='#008000' >//&nbsp;把物理内存绑定到虚拟地址空间</font>  
<font color='#0000ff' >BOOL</font>&nbsp;VirtualCopy(&nbsp;  
&nbsp;&nbsp;LPVOID&nbsp;lpvDest,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;虚拟内存的目标地址</font>  
&nbsp;&nbsp;LPVOID&nbsp;lpvSrc,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;物理内存地址</font>  
&nbsp;&nbsp;DWORD&nbsp;cbSize,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;要绑定的大小</font>  
&nbsp;&nbsp;DWORD&nbsp;fdwProtect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;访问权限</font>  
);  
VirtualAlloc对虚拟内存的申请分为两步，保留MEM\_RESERVE和提交MEM\_COMMIT。其中MEM\_RESERVE只是在进程的虚拟地址空间内保留一段，并不分配实际的物理内存，因此保留的虚拟内存并不能被应用程序直接使用。MEM\_COMMIT阶段才真正的为虚拟内存分配物理内存。  
下面的代码显示了如何使用VirtualAlloc和VirtualCopy来访问物理内存。因为VirtualCopy负责把一段物理内存和虚拟内存绑定，所以VirtualAlloc的时候只需要对内存保留，没有必要提交。  
FpDriverGlobals&nbsp;=&nbsp;  
(PDRIVER_GLOBALS)&nbsp;VirtualAlloc(  
&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;  
&nbsp;&nbsp;&nbsp;&nbsp;DRIVER\_GLOBALS\_PHYSICAL\_MEMORY\_SIZE,&nbsp;  
&nbsp;&nbsp;&nbsp;&nbsp;MEM_RESERVE,&nbsp;  
&nbsp;&nbsp;&nbsp;&nbsp;PAGE_NOACCESS);  
&nbsp;<font color='#0000ff' >if</font>&nbsp;(FpDriverGlobals&nbsp;==&nbsp;NULL)&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;ERRORMSG(DRIVER\_ERROR\_MSG,&nbsp;(TEXT(<font color='#ff00ff' >&#8221;&nbsp;VirtualAlloc&nbsp;failed!\r\n&#8221;</font>)));  
&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >return</font>;  
&nbsp;}  
&nbsp;<font color='#0000ff' >else</font>&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >if</font>&nbsp;(!VirtualCopy(  
&nbsp;&nbsp;&nbsp;&nbsp;(PVOID)FpDriverGlobals,&nbsp;  
&nbsp;&nbsp;&nbsp;&nbsp;(PVOID)(DRIVER\_GLOBALS\_PHYSICAL\_MEMORY\_START),&nbsp;  
&nbsp;&nbsp;&nbsp;&nbsp;DRIVER\_GLOBALS\_PHYSICAL\_MEMORY\_SIZE,&nbsp;  
&nbsp;&nbsp;&nbsp;&nbsp;(PAGE\_READWRITE&nbsp;|&nbsp;PAGE\_NOCACHE)))&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRORMSG(DRIVER\_ERROR\_MSG,&nbsp;(TEXT(<font color='#ff00ff' >&#8220;VirtualCopy&nbsp;failed!\r\n&#8221;</font>)));  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >return</font>;  
&nbsp;&nbsp;&nbsp;&nbsp;}  
&nbsp;}  
CEDDK还提供了函数MmMapIoSpace用来把一段物理内存直接映射到虚拟内存。用MmMapIoSpace申请的内存要用MmUnmapIoSpace释放，此函数的原形如下：  
PVOID&nbsp;MmMapIoSpace(&nbsp;  
&nbsp;&nbsp;PHYSICAL_ADDRESS&nbsp;PhysicalAddress,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;起始物理地址</font>  
&nbsp;&nbsp;ULONG&nbsp;NumberOfBytes,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;要映射的字节数</font>  
&nbsp;&nbsp;BOOLEAN&nbsp;CacheEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;是否缓存</font>  
);

<font color='#0000ff' >VOID</font>&nbsp;MmUnmapIoSpace(&nbsp;  
&nbsp;&nbsp;PVOID&nbsp;BaseAddress,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;MmMapIoSpace返回的起始虚拟地址</font>  
&nbsp;&nbsp;ULONG&nbsp;NumberOfBytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#008000' >//&nbsp;</font>  
);  
其实，MmMapIoSpace函数内部也是调用VirtualAlloc和VirtualCopy函数来实现物理地址到虚拟地址的映射的。MmMapIoSpace函数的原代码是公开的，我们可以从%_WINCEROOT%\<font color='#0000ff' >PUBLIC</font>\COMMON\OAK\DRIVERS\CEDDK\DDK\_MAP\ddk\_map.c得到。从MmMapIoSpace的实现我们也可以看出VirtualAlloc和VirtualCopy的用法：  
PVOID&nbsp;MmMapIoSpace&nbsp;(  
&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >IN</font>&nbsp;PHYSICAL_ADDRESS&nbsp;PhysicalAddress,  
&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >IN</font>&nbsp;ULONG&nbsp;NumberOfBytes,  
&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >IN</font>&nbsp;BOOLEAN&nbsp;CacheEnable  
&nbsp;&nbsp;&nbsp;&nbsp;)  
{  
PVOID&nbsp;pVirtualAddress;&nbsp;ULONGLONG&nbsp;SourcePhys;&nbsp;  
ULONG&nbsp;SourceSize;&nbsp;<font color='#0000ff' >BOOL</font>&nbsp;bSuccess;

&nbsp;&nbsp;&nbsp;&nbsp;SourcePhys&nbsp;=&nbsp;PhysicalAddress.QuadPart&nbsp;&&nbsp;~(PAGE_SIZE&nbsp;&#8211;&nbsp;1);  
&nbsp;&nbsp;&nbsp;&nbsp;SourceSize&nbsp;=&nbsp;NumberOfBytes&nbsp;+&nbsp;(PhysicalAddress.LowPart&nbsp;&&nbsp;(PAGE_SIZE&nbsp;&#8211;&nbsp;1));

&nbsp;&nbsp;&nbsp;&nbsp;pVirtualAddress&nbsp;=&nbsp;VirtualAlloc(0,&nbsp;SourceSize,&nbsp;MEM\_RESERVE,&nbsp;PAGE\_NOACCESS);  
&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >if</font>&nbsp;(pVirtualAddress&nbsp;!=&nbsp;NULL)  
&nbsp;&nbsp;&nbsp;&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bSuccess&nbsp;=&nbsp;VirtualCopy(
  
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pVirtualAddress,&nbsp;(PVOID)(SourcePhys&nbsp;>>&nbsp;8
  
),&nbsp;SourceSize,  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAGE\_PHYSICAL&nbsp;|&nbsp;PAGE\_READWRITE&nbsp;|&nbsp;(CacheEnable&nbsp;?&nbsp;0&nbsp;:&nbsp;PAGE_NOCACHE));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >if</font>&nbsp;(bSuccess)&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ULONG)pVirtualAddress&nbsp;+=&nbsp;PhysicalAddress.LowPart&nbsp;&&nbsp;(PAGE_SIZE&nbsp;&#8211;&nbsp;1);  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >else</font>&nbsp;{  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VirtualFree(pVirtualAddress,&nbsp;0,&nbsp;MEM_RELEASE);  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pVirtualAddress&nbsp;=&nbsp;NULL;  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  
&nbsp;&nbsp;&nbsp;&nbsp;}  
&nbsp;&nbsp;&nbsp;&nbsp;<font color='#0000ff' >return</font>&nbsp;pVirtualAddress;  
}  
此外，Windows&nbsp;CE还供了AllocPhysMem函数和FreePhysMem函数，用来申请和释放一段连续的物理内存。函数可以保证申请的物理内存是连续的，如果函数成功，会返回虚拟内存的句柄和物理内存的起始地址。这对于DMA设备尤为有用。在这里就不详细介绍了，读者可以参考Windows&nbsp;CE的联机文档。