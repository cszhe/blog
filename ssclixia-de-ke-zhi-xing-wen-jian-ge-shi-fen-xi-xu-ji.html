<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>SSCLI下的可执行文件格式分析（续集） | Zongjian’s blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="SSCLI下的可执行文件格式分析（续集）" />
<meta name="author" content="omale" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="闲来无事了，接着写吧。 上回书说到，一个Assembly的MetaData里面大概会有40多种表，然后我们根据一个例子分析了SSCLI下的PE文件的结构和MetaData其中的两种表Module和TypeRef。这次我们依然结合上次的例子，把剩余的几张元数据表分析完。 剩余还有12种元数据表，分别是TypeDef，Field，Method，Param，MemberRef，CustomAttribute，StandAloneSig，PropertyMap，Property，MethodSemantic，Assembly和AssemblyRef。像上面一样，我们首先看表类型的定义，在clr\src\md\runtime\metamodelcolumndefs.h中。" />
<meta property="og:description" content="闲来无事了，接着写吧。 上回书说到，一个Assembly的MetaData里面大概会有40多种表，然后我们根据一个例子分析了SSCLI下的PE文件的结构和MetaData其中的两种表Module和TypeRef。这次我们依然结合上次的例子，把剩余的几张元数据表分析完。 剩余还有12种元数据表，分别是TypeDef，Field，Method，Param，MemberRef，CustomAttribute，StandAloneSig，PropertyMap，Property，MethodSemantic，Assembly和AssemblyRef。像上面一样，我们首先看表类型的定义，在clr\src\md\runtime\metamodelcolumndefs.h中。" />
<link rel="canonical" href="https://www.hezongjian.com/ssclixia-de-ke-zhi-xing-wen-jian-ge-shi-fen-xi-xu-ji.html" />
<meta property="og:url" content="https://www.hezongjian.com/ssclixia-de-ke-zhi-xing-wen-jian-ge-shi-fen-xi-xu-ji.html" />
<meta property="og:site_name" content="Zongjian’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2005-02-06T21:42:54-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="SSCLI下的可执行文件格式分析（续集）" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"omale"},"dateModified":"2005-02-06T21:42:54-05:00","datePublished":"2005-02-06T21:42:54-05:00","description":"闲来无事了，接着写吧。 上回书说到，一个Assembly的MetaData里面大概会有40多种表，然后我们根据一个例子分析了SSCLI下的PE文件的结构和MetaData其中的两种表Module和TypeRef。这次我们依然结合上次的例子，把剩余的几张元数据表分析完。 剩余还有12种元数据表，分别是TypeDef，Field，Method，Param，MemberRef，CustomAttribute，StandAloneSig，PropertyMap，Property，MethodSemantic，Assembly和AssemblyRef。像上面一样，我们首先看表类型的定义，在clr\\src\\md\\runtime\\metamodelcolumndefs.h中。","headline":"SSCLI下的可执行文件格式分析（续集）","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hezongjian.com/ssclixia-de-ke-zhi-xing-wen-jian-ge-shi-fen-xi-xu-ji.html"},"url":"https://www.hezongjian.com/ssclixia-de-ke-zhi-xing-wen-jian-ge-shi-fen-xi-xu-ji.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://www.hezongjian.com/feed.xml" title="Zongjian&apos;s blog" />
</head>
<body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Zongjian&#39;s blog</a>

    <nav class="site-nav">
      <a class="page-link" href="/">Home</a>
      <a class="page-link" href="/categories/">Categories</a>
      <a class="page-link" href="/tags/">Tags</a>
      <a class="page-link" href="/archive/">Archive</a>
    </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">SSCLI下的可执行文件格式分析（续集）</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2005-02-06T21:42:54-05:00" itemprop="datePublished">
        February 6, 2005
      </time></div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>闲来无事了，接着写吧。<br />
上回书说到，一个Assembly的MetaData里面大概会有40多种表，然后我们根据一个例子分析了SSCLI下的PE文件的结构和MetaData其中的两种表Module和TypeRef。这次我们依然结合上次的例子，把剩余的几张元数据表分析完。<br />
剩余还有12种元数据表，分别是TypeDef，Field，Method，Param，MemberRef，CustomAttribute，StandAloneSig，PropertyMap，Property，MethodSemantic，Assembly和AssemblyRef。像上面一样，我们首先看表类型的定义，在clr\src\md\runtime\metamodelcolumndefs.h中。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
// TypeDef  
SCHEMA\_TABLE\_START(TypeDef)  
SCHEMA_ITEM(TypeDef, ULONG, Flags)  
SCHEMA\_ITEM\_STRING(TypeDef, Name)  
SCHEMA\_ITEM\_STRING(TypeDef, Namespace)  
SCHEMA\_ITEM\_CDTKN(TypeDef, Extends, TypeDefOrRef)  
SCHEMA\_ITEM\_RID(TypeDef, FieldList, Field)  
SCHEMA\_ITEM\_RID(TypeDef, MethodList, Method)   SCHEMA\_TABLE\_END(TypeDef)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
//Field  
SCHEMA\_TABLE\_START(Field)  
SCHEMA_ITEM(Field, USHORT, Flags)  
SCHEMA\_ITEM\_STRING(Field,Name)  
SCHEMA\_ITEM\_BLOB(Field,Signature)   SCHEMA\_TABLE\_END(Field)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
//Method  
SCHEMA\_TABLE\_START(Method)  
SCHEMA_ITEM(Method, ULONG, RVA)  
SCHEMA_ITEM(Method, USHORT, ImplFlags)  
SCHEMA_ITEM(Method, USHORT, Flags)  
SCHEMA\_ITEM\_STRING(Method,Name)  
SCHEMA\_ITEM\_BLOB(Method,Signature)  
SCHEMA\_ITEM\_RID(Method,ParamList,Param)   SCHEMA\_TABLE\_END(Method)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
// Param  
SCHEMA\_TABLE\_START(Param)  
SCHEMA_ITEM(Param, USHORT, Flags)  
SCHEMA_ITEM(Param, USHORT, Sequence)  
SCHEMA\_ITEM\_STRING(Param,Name)   SCHEMA\_TABLE\_END(Param)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
//MemberRef  
SCHEMA\_TABLE\_START(MemberRef)  
SCHEMA\_ITEM\_NOFIXED()  
SCHEMA\_ITEM\_CDTKN(MemberRef,Class,MemberRefParent)  
SCHEMA\_ITEM\_STRING(MemberRef,Name)  
SCHEMA\_ITEM\_BLOB(MemberRef,Signature)   SCHEMA\_TABLE\_END(MemberRef)
</code></pre></div></div>

<p>//————————————————————————-<br />
//CustomAttribute<br />
SCHEMA_TABLE_START(CustomAttribute)<br />
SCHEMA_ITEM_NOFIXED()<br />
SCHEMA_ITEM_CDTKN(CustomAttribute,Parent,HasCustomAttribute)<br />
SCHEMA_ITEM_CDTKN(CustomAttribute,Type,CustomAttributeType)<br />
SCHEMA_ITEM_BLOB(CustomAttribute,Value)<br />
SCHEMA_TABLE_END(CustomAttribute)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
//StandAloneSig  
SCHEMA\_TABLE\_START(StandAloneSig)  
SCHEMA\_ITEM\_NOFIXED()  
SCHEMA\_ITEM\_BLOB(StandAloneSig,Signature)   SCHEMA\_TABLE\_END(StandAloneSig)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
//PropertyMap  
SCHEMA\_TABLE\_START(PropertyMap)  
SCHEMA\_ITEM\_NOFIXED()  
SCHEMA\_ITEM\_RID(PropertyMap,Parent,TypeDef)  
SCHEMA\_ITEM\_RID(PropertyMap,PropertyList,Property)  
SCHEMA\_TABLE\_END(PropertyMap)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
//Property  
SCHEMA\_TABLE\_START(Property)  
SCHEMA_ITEM(Property, USHORT, PropFlags)  
SCHEMA\_ITEM\_STRING(Property,Name)  
SCHEMA\_ITEM\_BLOB(Property,Type)  
SCHEMA\_TABLE\_END(Property)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
//MethodSemantics  
SCHEMA\_TABLE\_START(MethodSemantics)  
SCHEMA_ITEM(MethodSemantics, USHORT, Semantic)  
SCHEMA\_ITEM\_RID(MethodSemantics,Method,Method)  
SCHEMA\_ITEM\_CDTKN(MethodSemantics,Association,HasSemantic)  
SCHEMA\_TABLE\_END(MethodSemantics)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
// Assembly  
SCHEMA\_TABLE\_START(Assembly)  
SCHEMA_ITEM(Assembly, ULONG, HashAlgId)  
SCHEMA_ITEM(Assembly, USHORT, MajorVersion)  
SCHEMA_ITEM(Assembly, USHORT, MinorVersion)  
SCHEMA_ITEM(Assembly, USHORT, BuildNumber)  
SCHEMA_ITEM(Assembly, USHORT, RevisionNumber)  
SCHEMA_ITEM(Assembly, ULONG, Flags)  
SCHEMA\_ITEM\_BLOB(Assembly, PublicKey)  
SCHEMA\_ITEM\_STRING(Assembly, Name)  
SCHEMA\_ITEM\_STRING(Assembly, Locale)  
SCHEMA\_TABLE\_END(Assembly)

//&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-  
// AssemblyRef  
SCHEMA\_TABLE\_START(AssemblyRef)  
SCHEMA_ITEM(AssemblyRef, USHORT, MajorVersion)  
SCHEMA_ITEM(AssemblyRef, USHORT, MinorVersion)  
SCHEMA_ITEM(AssemblyRef, USHORT, BuildNumber)  
SCHEMA_ITEM(AssemblyRef, USHORT, RevisionNumber)  
SCHEMA_ITEM(AssemblyRef, ULONG, Flags)  
SCHEMA\_ITEM\_BLOB(AssemblyRef, PublicKeyOrToken)  
SCHEMA\_ITEM\_STRING(AssemblyRef, Name)  
SCHEMA\_ITEM\_STRING(AssemblyRef, Locale)   SCHEMA\_ITEM\_BLOB(AssemblyRef, HashValue)  
SCHEMA\_TABLE\_END(AssemblyRef)   这几个宏也可以展开为MetaData表的描述信息，由于在前面的文章中我们已经演示过展开Module和TypeRef定义的宏，这里就不再展开了。读者感兴趣的可以自己尝试一下。我们还是切入正题，开始逐一分析每个表。
</code></pre></div></div>

<p>TypeDef表描述了该程序集中的某个类型定义，它包含如下属性：4字节的Flags，Flags描述了这个类型的可访问性，例如C#中的public, private等等，具体的定义在clr/src/inc/Corhdr.h中。</p>

<p>// TypeDef/ExportedType attr bits, used</p>

<p>by DefineTypeDef.<br />
typedef enum CorTypeAttr<br />
{<br />
    // Use this mask to retrieve the type visibility information.</p>

<p>tdVisibilityMask        =   0x00000007,<br />
    tdNotPublic             =   0x00000000,     // Class is not public scope.<br />
    tdPublic                =   0x00000001,     // Class is public scope.<br />
    tdNestedPublic          =   0x00000002,     // Class is nested with public visibility.<br />
    tdNestedPrivate         =   0x00000003,     // Class is nested with private visibility.<br />
    tdNestedFamily          =   0x00000004,     // Class is nested with family visibility.<br />
    tdNestedAssembly        =   0x00000005,     // Class is nested with assembly visibility.<br />
    tdNestedFamANDAssem     =   0x00000006,     // Class is nested with family and assembly visibility.<br />
    tdNestedFamORAssem      =   0x00000007,     // Class is nested with family or assembly visibility.<br />
………………<br />
} CorTypeAttr;</p>

<p>指向#Strings流的两字节的Name索引，两字节的NameSpace索引，分别描述了类型的名称和命名空间。2个Byte的名为Extends的指向mdtTypeDefOrRef类型Coded Token的索引，描述了该类型继承了那个父类和实现了哪些接口。2个Byte的FieldList和MethodList索引，描述了该类型有哪些成员变量和成员函数，一个类型有哪些成员变量或成员函数应该是一个范围，这个范围的开始就是FieldList和MethodList所指向FieldDef或MethodDef中的方法，范围的结尾是FieldDef表结尾，或者下一个TypeDef中的FieldList指向的项。这样每个TypeDef占14个Byte。<br />
在本例中，一共有3个TypeDef，它们的二进制值分别是：00 00 00 00/01 00/00 00/00 00/01 00/01 00|01 00 10 00/2B 00/00 00/05 00/01 00/01 00|01 00 10 00/30 00/00 00/05 00/02 00/05 00。我们分析第一项，其Flags值为0x00000000，Name为0x0001，值为“<Module>”；NameSpace为空。其实这是一个伪类型，定义为模块级的函数和变量就放在这个里面，但是C#中似乎不允许定义模块级的方法和变量，所以这项实际上没什么用。  
那么接着分析第二项，其Flags的值为0x00100001，从CorTypeAttr的定义可以知道意思为tdPublic和tdBeforeFieldInit。Name索引是0x002B，值为“Echo”；Namespace值为空。Extends值为0x0005，由于它是个mdtTypeDefOrRef类型的Coded Token，解码后其实是0x01000001，正如上次分析的，指向TypeDef表的第一项:System.Object；然后是FieldList和MethodList，值都为0x0001。我们先看下一项Typedef的FieldList为0x0002，MethodList为0x0005，也就是说Echo类有一个Field，4个Method（我们猜一下：一个Field肯定就是private string toEcho了，4个Method么，DoEcho算一个，一个EchoString属性其实会被编译成两个Method，一个get一个set，最后一个其实是编译器给我们加上的构造函数）。综合一下，这个Typedef的意思是说，这个Assembly里面定义了一个Echo类，有public的访问属性，它继承自System.Object，它含有一个Field和四个方法。剩下一个Typedef就是Hello类了，就不再详细分析了。</Module></p>

<p>Field表描述了MetaData中的所有成员变量定义。Field表包含下面一些列：2个Byte的Flags，定义可参见clr/src/inc/Corhdr.h中的CorFieldAttr枚举，这里就不罗列了。2个Byte的到#Strings流的Name索引，2个Byte的到#Blob流的Signature索引。一个FieldDef有6个Byte。<br />
本例中仅有的1个FieldDef的值是01 00 36 00 0A 00。Flags的值为0x0001，参考CorFieldAttr，其意思为fdPrivate；Name的值是0x0036，值是“toEcho”；Signature的值是0x000A，对应#Blob流中的值是06 0E。总结一下，这个项表示该Assembly中有一个名为toEcho的Field，有Private的访问属性，签名是06 0E。</p>

<p>Method表描述了MetaData中的所有成员函数定义。Method标包含了下面一些列：4个Byte的RVA，两个Byte的ImpFlags，两个Byte的Flags，指向#Strings流的两个Byte的Name索引，指向#Blob流得两个Byte的Signature，两个Byte的ParamList。因此一个MethodDef有14个Byte。<br />
RVA定义了方法开始的偏移地址，注意，是针对当前段（也就是.text段的偏移，不是针对MetaData起始地址的偏移。）。ImpFlags是方法实现上的标记，定义可参见clr/src/inc/Corhdr.h中的CorMethodImpl枚举。Flags是方法上的其他标记，定义可参见clr/src/inc/Corhdr.h中的CorMethodAttr枚举。Name是这个方法的名称，Signature没多大意义，ParamList是指向ParamDef表的索引向，也是一个范围，范围开始结束的方法跟前面讲述的TypeDef中的FieldList，MethodList差不多。<br />
在本例中，一共有6个MethodDef，其值分别为：50 20 00 00/00 00/86 08/3D 00/0D 00/01 00|68 20 00 00/00 00/86 08/4C 00/11 00/01 00|7C 20 00 00 00 00 86 00 5B 00 0D 00 02 00|A8 20 00 00 00 00 86 18 62 00 16 00 02 00|C4 20 00 00/00 00/96 00/73 00/1E 00/02 00|F4 20 00 00 00 00 86 18 62 00 16 00 03 00。<br />
我们这次不看第1项，看第5项（因为这个比较有代表性，在IMAGE_COR20_HEADER中，我们知道EntryPointToken的值是0x60000005，那么Method的第5项就应该是入口的Main函数，这里顺便验证一下），其RVA的值为0x000020C4。那么，我们可以算得其偏移地址为 = 0x000020C4 – 0x00002000 + 0x00000200 = 0x000002C4，一会我们再看这里放了什么。ImpFlags值为0x0000，Flags值为0x0096，表示mdHideBySig | mdStatic | mdPublic。Name的值是0x0073，为“Main”；Signature值为0x001E，相应的#Blob数据为“00 01 01 1D 0E”。ParamList值为0x0002，表示指向ParamDef表的第二项。综合一下，第五项描述了一个方法，名字叫Main，有public static属性，有一个参数，代码开始于0x000002C4。<br />
下面就要分析IL代码的格式：为了节省空间（又是节省空间添的麻烦），SSCLI定义了两种方法格式，Tiny和Fat。当代码小于64 byte，并且没有局部变量的时候，我们可以选用Tiny方法,否则就只能Fat了。Tiny和Fat的定义可以在clr/src/inc/Corhdr.h中找到，列举如下，省略了一些关系不大的方法：</p>

<p>typedef enum CorILMethodFlags<br />
{ <br />
   // Indicates the format for the COR_ILMETHOD header <br />
    CorILMethod_FormatShift     = 3,    <br />
 &amp;</p>

<p>nbsp;  CorILMethod_FormatMask   &amp;</p>

<p>nbsp;  = ((1 « CorILMethod_FormatShift) – 1), <br />
    CorILMethod_TinyFormat      = 0x0002,         // use this code if the code size is even <br />
    CorILMethod_SmallFormat     = 0x0000,           <br />
    CorILMethod_FatFormat       = 0x0003,   <br />
    CorILMethod_TinyFormat1     = 0x0006,         // use this code if the code size is odd  <br />
} CorILMethodFlags;</p>

<p>/*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>***/<br />
/* Used when the method is tiny (&lt; 64 bytes), and there are no local vars */<br />
typedef struct IMAGE_COR_ILMETHOD_TINY<br />
{<br />
    BYTE Flags_CodeSize;    <br />
} IMAGE_COR_ILMETHOD_TINY;</p>

<p>/*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>*<strong>*</strong>/<br />
// This strucuture is the ”fat” layout, where no compression is attempted. <br />
// Note that this structure can be added on at the end, thus making it extensible<br />
typedef struct IMAGE_COR_ILMETHOD_FAT<br />
{<br />
    unsigned Flags    : 12;     // Flags    0x13<br />
    unsigned Size     :  4;     // size in DWords of this structure (currently 3)   0y0011<br />
    unsigned MaxStack : 16;     // maximum number of items (I4, I, I8, obj …), on the operand stack   0x2<br />
    DWORD   CodeSize;           // size of the code 0x22<br />
    mdSignature   LocalVarSigTok;     // token that indicates the signature of the local vars (0 means none)  0x11000002<br />
} IMAGE_COR_ILMETHOD_FAT;</p>

<p>typedef struct tagCOR_ILMETHOD_TINY : IMAGE_COR_ILMETHOD_TINY<br />
{<br />
    bool     IsTiny() const         { return((Flags_CodeSize &amp; (CorILMethod_FormatMask » 1)) == CorILMethod_TinyFormat); } <br />
    unsigned GetCodeSize() const    { return(((unsigned) Flags_CodeSize) » (CorILMethod_FormatShift-1)); } <br />
    unsigned GetMaxStack() const    { return(8); }  <br />
    BYTE*    GetCode() const        { return(((BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_TINY)); } <br />
} COR_ILMETHOD_TINY;</p>

<p>typedef struct tagCOR_ILMETHOD_FAT : IMAGE_COR_ILMETHOD_FAT<br />
{<br />
    unsigned GetSize() const {<br />
        BYTE* p = (BYTE*)this;<br />
        return *(p+1) » 4;<br />
    }<br />
    unsigned GetFlags() const {<br />
        BYTE* p = (BYTE*)this;<br />
        return ((unsigned)*(p+0)) | (( ((unsigned)*(p+1)) « 8) &amp; 0x0F);<br />
    }<br />
    bool IsFat() const {<br />
        return (*(BYTE*)this &amp; CorILMethod_FormatMask) == CorILMethod_FatFormat;<br />
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BYTE* GetCode() const {  
    return(((BYTE\*) this) + 4\*GetSize());  
}  
const COR\_ILMETHOD\_SECT* GetSect() const {  
    if (!(*(B &amp;#8230;
</code></pre></div></div>

  </div>

  <a class="u-url" href="/ssclixia-de-ke-zhi-xing-wen-jian-ge-shi-fen-xi-xu-ji.html" hidden></a>
</article>


      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Zongjian He</li>
          <li><a class="u-email" href="mailto:"></a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Personal blog of Zongjian He</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list">
  <li>
    <a href="https://www.hezongjian.com/feed.xml" target="_blank" title="Subscribe to syndication feed">
      <svg class="svg-icon grey" viewbox="0 0 16 16">
        <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
          11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
          13.806c0-1.21.983-2.195 2.194-2.195zM10.606
          16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
        />
      </svg>
    </a>
  </li>
</ul>
</div>

  </div>

</footer>

</body>

</html>
